---
title: "윈도우즈 시스템 프로그래밍 7장-세션1"
toc: true
toc_sticky: true
categories:
  - book
tags:
  - 윈도우 프로그래밍
  - 뇌를 자극하는 윈도우즈 시스템 프로그래밍
permalink: /categories/book/WindowsSystemProgramming/chapter7/session1
---
# 저자의 당부
## CreateFile

📍멤버<br>
[1]개방할 파일의 이름<br>
[2]읽기 및 쓰기모드 지정<br>
[3]파일의 공유방식을 지정한다.<br>
이떄 공유 대상의 기준은 다른 프로세스로, 동시 읽기 쓰기가 가능하냐 공유가 불가능하냐 등으로 나뉜다.<br>
[4]보안속성 지정<br>
[5]파일이 생성되는 방법을 지정<br>
[6]파일의 특성정보 설정<br>
[7]기존 존재 파일과 동일한 속성을 가지는 새 파일 만들 때 사용되는 전달인자<br>
[8]함수 호출 성공 시 파일의 핸들이 반환된다.
{: .notice--success}

파일 종료시 커널 오브젝트 핸들과마찬가지로 CloseHandle 함수를 호출해야한다.
## ReadFile

전달인자<br>
[1] 데이터 읽을 파일의 핸들 지정<br>
[2] 버퍼의 주소를 지정<br>
[3] 데이터의 크기를 바이트 단위로 지정<br>
[4] 데이터 크기를 얻기 위한 변수의 주소를 지정<br>
{: .notice--success}

## WriteFile

전달인자<br>
[1] 데이터 저장할 파일의 핸들 지정<br>
[2] 데이터를 저장하고 있는 버퍼의 주소를 지정<br>
[3] 데이터의 크기를 바이트 단위로 지정<br>
[4] 데이터 크기를 얻기 위한 변수의 주소를 지정<br>
{: .notice--success}

## ANSI 표준 입출력 함수
자, 우선 표준 입출력 함수의 특징 중 하나는 운영체제에 상관없이 지원하기 때문에 이식성이 좋다는 특징이 있다.<br>
또한 사용자와의 상효작용 등을 간단하게 출력하거나 입력받기 편하기 때문에 간단한 콘솔프로그램에서 주로 사용된다.<br>
### 용도와 목적
ANSI 표준 입출력 함수는 간단한 콘솔 기반의 텍스트 입출력을 담당한다.<br>
저자가 설명한 저 두 함수의 경우 windows api의 함수이며 주로 파일을 열거나 생성+파일에 대한 읽기/쓰기 작업을 수행하는 데에 사용된다.
# 프로세스간 통신의 의미
프로세스 통신을 아주 간단하게 정의하자면 둘 이상의 프로세스가 데이터를 주고 받는 행위이다.
## 프로세스 통신의 조건
프로세스 통신을 위해서는 이 둘이 직접 통신이 가능한지 아닌지부터 알아야한다.<br>
만약 두 프로세스가 직접 통신이 가능하면 그렇게 하면 되지만, 직접 통신이 불가능한 경우 이 둘을 연결해줄 매개체가 필요해진다.<br>
## 프로세스간의 만남
안타깝지만 프로세스는 서로 만나 데이터를 주고받는 것은 불가능하다.<br>
그렇기 때문에 이 둘이 만날 접선 장소가 필요한데, 앞선 장에서 설명하였듯 각 프로세스들은 자신에게 할당된 메모리 공간에만 접근이 가능하다.<br>
따라서 우리는 메모리 공간을 프로세스 둘이 만날 매개체로 만드는 것이 아니라, 자신의 메모리 속 필요한 정보를 꺼내어 어떤 매개체에 담고 정보를 받을 프로세스는 이 매개체에 접근하여 정보를 읽도록 진행하여야한다.
### 만나면 안될까
왜 프로세스는 자신에게 할당된 메모리 공간에만 접근이 가능하고 이외의 영역에는 접근이 불가능할까?<br>
아주 간단하게 설명하면 `프로그램의 신뢰성`이 떨어지는 것을 방지하기 위해서이다.<br>
만약 다른 프로세스에서도 마음대로 메모리 영역에 접근이 가능하다면, 메모리리 속 내용을 마음대로 수정하거나 덮어쓰는 등의 문제가 생겨 다시 작업을 해야하는 상황이 발생할 수도 있다.<br>
즉 이러한 방식으로 os가 작동하는 이유는 `보안`과 `격리성`때문이다.<br>
## 가상 메모리와 물리 주소
여기에서 한가지 의문이 들 수 있는 것은 A라는 프로세스의 메모리 영역 속 `0X1000`이라는 주소가 있을 때 B라는 프로세스의 메모리 영역에도 이 주소값이 있을 수 있을까라는 생각을 가질 수 있다.<br>
간단하게 설명하자면 이것은 반쪽짜리 설명인데, a라는 프로세스에서 가리키는 0x1000과 b라는 프로세스에서 가리키는 0x1000의 공간은 다르기 때문이다.<br>
운영체제는 이렇게 주소가 겹치는 경우에 대비하여 이런 가상주소들을 물리적인 공간을 나타내는 물리적 주소로 매핑하여 사용한다.
### 주소공간
주소공간은 가상 메모리의 범위를 나타내며, 32비트 아키텍처에서는 주소공간이 2의 32승 즉 4gb로 표현된다.
### 가상 메모리
각 프로세스는 위에서 설명하였듯 독립적인 가상 공간을 가지게 된다.<br>
그래서 A라는 프로세스에서 0x1000라는 주소는 a내에서 특정 데이터/코드를 가리키며, B프로세스 속 가상주소 0x1000은 b내에서 다른 데이터와 코드를 가리키게 된다.
### 물리주소
한문장으로 표현하면 `메모리 자체의 인덱스`이다.<br>
각 프로세스의 가상 주소는 운영체제를 통해서 물리적인 주소로 매핑된다.<br>
따라서 가상 주소가 겹친다고해도 물리주소는 겹치지 않도록 os가 알아서 조절해준다.
+주로 하드웨어 영역에서 사용된다.
## 포인터가 가리키는 주소는?
포인터를 사용하여 우리가 읽는 주소는 바로 가상 주소이다.<br>
우리가 포인터를 사용해서 메모리에 접근하면, 운영체제는 실제 주소로 자동 매핑하여준다.