---
title: "윈도우즈 시스템 프로그래밍 5장-세션 1,2,3"
toc: true
toc_sticky: true
categories:
  - book
tags:
  - 윈도우 프로그래밍
  - 뇌를 자극하는 윈도우즈 시스템 프로그래밍
permalink: /categories/book/WindowsSystemProgramming/chapter5/session1
---
# 시작 전 소개
![뇌를 자극하는 윈도우즈 프로그래밍](https://www.hanbit.co.kr/data/books/B7673779595_l.jpg){: width="400" height="200" .align-center}<br>
[1챕터 정리본 바로가기](https://park-yina.github.io/categories/book/WindowsSystemProgramming/chapter1)<br>
[2챕터 정리본 바로가기](https://park-yina.github.io/categories/book/WindowsSystemProgramming/chapter2)<br>
[3챕터 정리본 바로가기](https://park-yina.github.io/categories/book/WindowsSystemProgramming/chapter3)<br>
[4챕터 세션1 정리본](https://park-yina.github.io/categories/book/WindowsSystemProgramming/chapter4/session1)<br>
[4챕터 세션 2 정리본](https://park-yina.github.io/categories/book/WindowsSystemProgramming/chapter4/session2)
# 프로세스의 이해
프로세스란 실행 중에 있는 프로그램을 의미한다.<br>
`.exe`파일을 실행하여 램에 할당이 이루어지고, 이 메모리 공간으로 바이너리 코드가 올라가는 순간부터 프로그램은 프로세스라고 불리게 된다.<br>
그렇다면 멀티 프로세스 운영체제란 무엇일까?<br>
간단하게 설명하면 둘 이상의 프로세스가 존재할 수 있는 운영체제라는 뜻이다.<br>
카카오톡을 켜놓고 인터넷 익스플로어를 실행시킨다거나 하는 작업등이 가능한 것은, 윈도우가 멀티 프로세스 운영체제이기 때문이다.<br>
## 프로세스 구성의 요소
![메모리 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Ft05ky%2FbtqKqySZfku%2FEp8GYaxIHEw7Jpre4W2ag1%2Fimg.png){: .align-center}
참고로 위 그림과 같은 메모리 구조는 실행되고 있는 프로세스 개수만큼 실행된다.
### code영역
프로그램 실행을 하면, 실행파일 내에 존재하는 명렁어가 메모리상에 올라가서 순차적으로 처리된다.<br>
이때 명령어가 올라가는 메모리 영역이 바로 코드 영역이다.
### DATA영역
전역변수나 static 변수의 할당을 위해 존재
### STACK
지역변수 할당과 함수 호출 시 전달되는 인자값들을 저장하는 영역
### Heap
malloc나 calloc함수에 의해 이루어진 동적할당을 위해 존재하는 곳이 힙 영역이다.<br>
## 레지스터 셋
레지스터는 임시의 저장공간이다.<br>
레지스터는 프로그램이 실행되면 메인메모리(램)의 내용을 CPU로 가져와서 저장한 뒤 alu로 보내 필요한 연산을 하거나 메인메모리로 정보를 보내는 등의 일을 할 때 필요하다.<br>
따라서 레지스터의 상태 역시 프로세스의 일부로 포함시켜 말할 수 있다.
# 프로세스의 스케줄링과 상태변화
## 프로세스의 스케줄링
기본원리: CPU는 하나인데 여러개의 프로세스가 실행가능한 것은 CPU가 아주 빨라서 할당 시간을 나누면서 작동하기 때문이다.<br> 이 과정에서 CPU자원을 어떻게 공정하고 효율적으로 할당하는가가 바로 스케줄링의 목적이다.<br>
간단 설명: CPU할당 순서 및 방법을 결정짓는 일->스케줄링/이때 사용되는 알고리즘->스케줄링 알고리즘<br>
이 알고리즘을 적용하여 실제로 프로세스를 관리하는 운영체제 모듈->스케줄러(소프트웨어적으로 구현)
![스케줄러에 의한 프로세스 관리](https://velog.velcdn.com/images%2Fjacod2%2Fpost%2F496e45ce-c575-4c68-93ec-fd5ea1930180%2Fimage.png){: .align-center}
### 멀티 프로세스에 대해서
◼고전적 방식<br>
A를 실행시키고 A가 완전히 종료되면 B를 실행<br>
B가 완전히 종료되면 C를 실행시키는 방식으로 우리가 실행해야할 일을 순차적으로 실행시킨다.<br>
◼동시 실행 방식<br>
A,B,C를 모두 실행시키고 운영체제의 스케줄러에 의해 프로세스들이 관리되도록 한다.<BR>
CPU의 실행시간을 나눠 할당받아 실행하는 형태가 된다.<BR>
과연 어떤 것이 효율적일까?<BR>
일반적인 경우 입출력이 종료되면 그에 대한 화면을 실행하는 고전적 방식이 효율적이라고 생각될 수 있다.<BR>
그러나, 하나의 업무가 아닌 여러 개의 업무를 해야하는 상황이라면 동시 실행 방식을 통해 사용하는 프로세스만 실행시키고, 그렇지 않은 프로세스는 대기 하는 것이 효율적일 확률이 크다.<br>
#### 고전적 방식의 장단점
장점1.간단하게 예측이 가능하다.<br>
한번에 하나만 작업하기 때문에 예측이 쉽게 가능하여, 디버깅이 용이하다.<br>
장점2.자원충돌 가능성의 최소화<br>
하나의 작업이 완전히 종료되어야 그 다음 작업이 실행되기 때문에, 자원간의 충돌 가능성을 최소화할 수 있다.<br>
단점1.실행시간의 증가<br>
전체작업이 종료될 때까지 기다려야 하므로 전체 처리 시간이 증가할 수 있다.<br>
단점2.자원 활용이 낮다.<br>
다음 작업이 시작될 때까지 기다리는 동안 다른 자원은 놀고있게 되므로 자원의 활용도는 낮아진다.
#### 동시 실행 방식의 장단점
장점1.자원 활용의 최적화<br>
여러 작업을 동시에 실행하므로 자원을 최대한 활용할 수 있다.<br>
(물론 우선순위 스케줄링 어떻게 하느냐에 따라 정도는 달라질 수 있다)<br>
장점2.응답시간 단축<br>
하나의 작업이 끝나지 않아도 다른 작업이 진행되므로 응답시간의 단축이 가능하다.<br>
단점1. 동기화와 상태 관리의 어려움<br>
여러 작업이 동시에 실행되기 떄문에 실행 여부를 알기 어려울 때가 생길 수 있다.<br>
따라서 개발 시 신경써야 될 부분이 늘어난다.<br>
단점2. 교착상태<br>
공유 자원에 대한 요구가 엉켜 무한대기가 발생할 수 있다.<br>
단점3. 레이스 컨디션<br>
두 개 이상의 프로세스 혹은 스레드가 자원을 서로 공유하려는 과정에서 문제가 발생할 수 있다.<br>
## 프로세스의 상태 변화
멀티프로세스 운영체제는 시간의 흐름에 따라 프로세스의 상태가 계속해서 변화한다.<br>
![프로세스의 상태 변화](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fv7jMa%2FbtqWX4TbWpm%2F4KTWStGqzDMAWM1lob2G1K%2Fimg.png){: .align-center}
### 단계 1: Start->Ready
프로세스는 생성과 동시에 Ready즉 준비 상태로 들어간다.<br>
여기서 준비 상태란 말 그대로 스케줄러에 의해 선택 받아 running이 되기 위한 준비를 하는 것을 의미한다.<br>
준비 상태일 때에는 CPU에 할당을 기다리다가 스케줄러에 의해 선택되면 CPU의 할당을 받아 실행 상태로 전환된다.<br>
### 단계2: Ready->Running
스케줄러는 준비 상태에 있는 프로세스 중 하나를 골라(스케줄링 알고리즘에 기반을 두고) CPU에 의해 실행되도록 한다.<br>
### 단계3 Running->Ready
프로세스의 운영상태에 따라 현재 작동중인 프로세스를 준비 상태로 바꾸는 경우도 있다.<br>
예를 들어 새로 올라온 프로세스가 현재 작동중인 프로세스보다 우선순위가 높다면<br>
일반적으로 현재 작동중인 프로세스는 `준비`상태로 돌아가서 새로 올라온 프로세스가 실행 종료되기를 기다리게 된다.<br>
뿐만아니라 입출력 요청, 자원 부족등을 이유로 프로세스가 준비 상태로 돌아가기도 한다.
### 단계4 Running->Blocked
실행중에 있는 프로세스가 실행을 멈추는 상태로 들어가는 것<br>
일반적으로 데이터 입출력은 프로그램의 상당 시간을 소모한다.<br>
따라서 이 시간동안에는 입출력인 프로세스는 Block상태로 만든 뒤 ready상태에 있는 프로세스는 하나를 실행시킨다.<br>
예를 들어 A가 파일출력을 하는 상황이 된다면, Block을 하고 파일을 출력하는 상태로 변하고 준비 상태이던 B는 Running의 단계에 돌입하게 된다.<br>
### 단계5 Blocked->Ready
block상태와 ready 상태의 가장 큰 차이가 무엇일까?<br>
스케줄러에 의해 선택받을 수 있는 가능성 유무이다.<br>
block상태는 스케줄러에 의해 선택 받을 수 없는 상태이며 상황에 따라서는 프로그램 종료 상태에 들어갈 수도 있다.<br>
그에 비해 ready상태는 자신의 순위가 돌아오면 언제든 스케줄러에게 선택을 받는 것이 가능하다.<br>
따라서 프로그램이 종료되어야 하는 상황이 아니라면 block상태에 돌입한 프로세서는 스케줄러의 선택을 받기 위해 다시 ready로 돌아가게 된다.<br>
# 컨텍스트 스위칭
간단하게 정의하면 멀티 프로세스 os에서 다음 우선 순위의 프로세스가 실행될 때에 기존 프로세스의 상태나 값을 저장하고 새로운 프로세스에 대한 값으로 교체하는 작업이다.<BR>
위에서 말한 교착상태에 들어가거나 하는 문제들 역시 이 컨텍스트 스위칭과정에서 생기는 문제들이다.<BR>
그런데 이러한 작업들을 실행하려면 저자가 이야기하듯 시스템에 부담을 주어야만 한다.<br>
그렇다면 우리는 `왜 시스템에 부담을 주면서까지`이러한 작업들을 해야할까<br>
간단하게 말하자면 역설적으로 컨텍스트 스위칭은 프로세스 간 CPU를 효율적으로 공유하는 과정에서 시스템 전반의 성능을 향상시킨다.<br>
그리고 다중작업 환경이라면 사용자는 동시에 여러 작업의 수행을 원하게 되는데, 이를 실행시키기 위해서는 컨텍스트 스위칭이 무조건적으로 필요해진다.<br>
# 공부 시 참조 링크 첨부
[멀티 프로세스에 대한 심화링크](https://icksw.tistory.com/127)