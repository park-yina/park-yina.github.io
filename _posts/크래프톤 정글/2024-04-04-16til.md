---
title: "크래프톤 정글 16DAY isa와 cpu아키텍처"
toc: true
toc_sticky: true
categories:
  - jungle
tags:
  - CS
header:
  teaser: "https://blog.in-coder.com/wp-content/uploads/2023/07/image-2.png"
permalink: /categories/jungle/Til16
---
# 레퍼런스

- cs:app도서 3.1부터 3.3<br>
- 13일차 til(cisc/risc)<br>
- 한권으로 읽는 컴퓨터 구조와 프로그래밍(오현식 역)

# isa에 대한 개념 잡기

13일차 til에 나오는 cisc와 risc는 isa의 종류이다.<br>
즉 cisc와 risc는 isa의 어떤 속성이나 성격 특징 등을 보여주며, isa와 cpu아키텍처는 필연적으로 서로에게 영향을 주게 된다.

# cpu아키텍처와 isa의 아키텍처
isa에 들어있는 명령어를 뜯어보면 `01`의 나열인 것 쯤은 16일 til까지 보았으니 대충 알 것이다.<br>
이 01의 길이에 영향을 주는 것이 바로 cpu의 아키텍처인데, 이는 cpu아키텍처에 따라 명령어를 해독하는 방식이 달라지기 때문이다.<br>
명령어 해독 이야기가 나와서 덧붙이는 말이지만, 프로그램의 실행 흐름(처리방식)과 어셈블리 코드는 일치가 되지 않을 수도 있다.
# 파이프라이닝시
위에 설명을 들으면 isa의 명령어 길이와 cpu메모리 상 존재하는 주소의 길이가 100프로 일치할 것 같지만 그렇지는 않다.<br>
파이프라이닝과 같이 명령어를 쪼개는 기술도 있으며, 다이렉트 모드냐 인다이렉트 모드냐에 따라 주소를 참조할 때에도 가상 메모리 주소를 참조하여 인스트럭션 수준의 병렬성을 통한 최적화를 할 수도 있기 때문이다.
# 링커의 임무와 레지스터의 작동방식
링커의 임무는 크게 보았을 때, 실행할 코드 위치와 함수 호출을 일치시키는 일과 실제 메모리 주소와 가상 주소를 매핑시키는 일이 있다.<br>
이는 레지스터의 작동방식과도 밀접한 영향을 지닌다.
## 레지스터의 작동방식
레지스터는 기본적으로 참조방식으로 작동한다.<br>
이러한 참조나 복사는 단순하게 얕은복사냐 깊은복사냐 하는 차원의 문제가 아니라, `메모리-레지스터` 혹은 `레지스터-레지스터`간의 복사나 참조를 의미한다.
## 레지스터는 페이지 교체가 없다
레지스터는 캐시보다 용량이 작지만, 페이지 교체 알고리즘이 따로 존재하지 않는다.<br>
이게 상당히 이상하게 다가올 수 있는데 여기에는 몇 가지 이유가 있다.
### 레지스터 존재의 이유
레지스터는 기본적으로 `우편함` 혹은 `투두 리스트`로 비유되곤하는데, 레지스터는 메모리의 관리보다는 프로세서의 연산에 대한 지원을 하기 위해 사용되는 공간이기 때문이다.<br>
### 분업화
이러한 레지스터의 특징을 잘 활용하기 위하여, 현대 컴퓨터는 레지스터 파일이라는 시스템을 활용하여 여러 개의 레지스터를 임무별로 계층적으로 잘 분업화를 해두었다.<br>
캐시설계에 있어서 우리가 페이지 교체 알고리즘을 고려하는 것이 바로 캐시의 지역성에서부터 오는 한계라는 것을 고려하여 생각해본다면, 왜 레지스터에는 페이지 교체 시스템이 없는지 감이 올 것이다.
### 아주 빠르다
한 클럭 사이클 내에서 데이터 전달이 이루어지는 레지스터의 특성상 굳이 페이지를 교체 할 필요조차 없다.<br>
그냥 다음 사이클 이전까지 레지스터를 비워두고 새로운 자료를 받으면 되는 것이다.
