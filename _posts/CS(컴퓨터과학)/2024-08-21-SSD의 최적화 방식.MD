---
title:  "HDD와 SSD파헤치기-SSD편2(SSD의 데이터 수정 및 최적화)"
toc: true
toc_sticky: true
categories:
  - cs
tags:
  - 컴퓨터과학
  - CSAPP
toc_label: "SSd탐구"
header:
  teaser: "https://image.semiconductor.samsung.com/image/samsung/p6/semiconductor-kr/newsroom/news/samsungs-980-nvme-ssd-combines-speed-and-affordability-to-set-a-new-standard-in-consumer-ssd-performance_PC_1.png?$ORIGIN_PNG$"
permalink: /categories/cs/ssd2
---
# 관련된 게시물
- [hdd와 ssd의 차이 키워드-hdd편](https://park-yina.github.io/categories/cs/hdd1)<BR>
- [HDD와 SSD의 차이 키워드-SSD1편](https://park-yina.github.io/categories/cs/ssd1)
# SSD의 데이터 쓰기2(정보의 수정)
ssd1편에서는 일반적인 데이터 쓰기에 대한 글을 작성하였다.<br>
그렇다면 기존에 있는 데이터를 수정하여 저장하려면 어떡해야할까?<br>
우선 페이지는 덮어쓰기가 불가능하기 때문에 기존의 데이터를 어디론가 옮겨놓거나 삭제를 한 뒤 새로운 데이터를 저장하는 과정을 거쳐야할 것이다.<br>
그러나 ssd는 최적화를 위해 임시적으로 기존의 블록을 지우는 거이 아니라 독특한 방식을 사용하는데 이 게시물에서는 이러한 ssd의 최적화 방식을 자세히 알아보도록 하자.
## 수정 데이터의 작업 처리 과정
- 수정 데이터는 빈 페이지에 기록<br>
- 기존 페이지의 블록은 그때그때 삭제하는 것이 아니라, 유요하지 않은 데이터임을 표시<br>
    - ssd에는 오류 검증 코드가 있는데 이것을 통해 쓰기의 맨 마지막 단계에서 실질적으로 유효한 코드인지 아닌지 판단
- GC(가비지 컬렉션)<br>
    - 유효하지 않은 페이지가 쌓였을 때에는 gc가 작동하여 유한효 데이터만 컨트롤러에 의해 다른 블록으로 옮기는 과정을 거친다.<br>
    - 이후 유효하지 않은 페이지가 담겨있는 전체 블록을 삭제한다(이는 삭제가 블록 단위로만 이루어지기 때문)<br>
- 위 과정을 거친 뒤에 삭제된 블록은 다시 쓱가 가능한 공간으로 바뀐다.
- 수정본이 저장되는 과정은 게시물1에서 서술한 쓰기 과정(명령 수신 해석/페이지 찾기/크기조정/캐시에 저장/페이지 기록 확인/최적화)와 동일하므로 생략한다.
# SSD의 최적화 방식
앞선 게시물에서 SSD는 쓰기 증폭 현상 예방 및 읽기 쓰기 속도의 증가를 위하여 독특한 최적화 방식들을 쓴다고 설명하였다.<br>
그중 대표적인 몇가지에 대해 알아보도록 하자.
## GC(가비지 콜렉션)
- 삭제는 페이지가 아닌 여러개의 페이지가 모인 블록의 단위로 이루어진다.<br>
따라서 다른 작업에 비해 오랜 시간이 걸리므로 삭제 명령은 한꺼번에 모았다가 이루어지는 것이 유리하다.<br>
- GC는 이러한 이유에서 유효하지 않은 데이터로 표기된 페이지들을 모아놓고(블록으로), 이 데이터들을 한꺼번에 삭제한 뒤 데이터를 재배치하는 작업까지 진행한다.<br>
- 데이터를 재배치하는 작업을 함께 하는 이유는 ssd의 셀은 쓸 수 있는 횟수가 수명처럼 정해져있으므로, 고르게 닳을 수 있도록 하기 위해서이다.
## 오류 검출
- SSD의 오류검출은 크게 `ECC`와 `checkSum`을 통하여 이루어진다.<br>
이 둘은 각각 확인 가능한 오류 검출의 범위 및 역할이 다르다.
### ECC
ECC는 오류 검출 코드 중 하나로, 데이터의 저장시 함께 저장된다.<br>
데이터를 읽을 때 역시 위 코드를 검사하여 데이터가 유효한지(손상 여부)를 확인하고, 손상이 있다면 이를 감지하고 수정하는 것이 가능하다.
### checkSum
데이터의 무결성을 보증한다는 데에서는 ecc와 동일하나, 보다 간결한 역할을 한다고 이해하면 된다.<br>
체크썸도 데이터를 읽을 때에 코드 검사가 이루어지는데, ECC와 다르게 데이터의 손상 여부 즉 무결성 보장에 대해서는 확인이 가능하나 수정은 불가하다.
## 웨어레벨링
각 셀이 모두 균등한 정도의 업무를 분배 받아 작업이 고르게 이루어지도록 하며, 최종적으로는 ssd의 수명을 최대한 효율적으로 사용할 수 있도록 해주는 최적화 방법이다.<br>
웨어라벨링에는 동적 웨어 라벨링과 정적 웨어라벨링이 있다.
### 동적 웨어라벨링
기본적으로 SSD의 데이터는 정적 데이터(드라이버와 같은 파일들)와 동적 데이터로 나뉜다.<br>
정적 데이터는 물리적 블록에서 거의 쓰여지지 않고도 않고 거의 변경도 되지 않을 정보이며(즉 쓰기/삭제도 적은 정보로 굉장히 적은 양만 여기에 속한다), 동적 데이터는 자주 재프로그래밍되며 변경 역시 잦은 정보로 우리가 사용하는 대부분의 데이터는 여기에 속할 것이다.<br>
동적 웨어라벨링은 이러한 동적 데이터들을 어떻게 셀에 적재할 것인가에 대한 방법이다.
#### 동적 웨어라벨링의 작동 방법
ssd컨트롤러는 데이터 블록을 사용할 때마다 사용된 블럭이 어떤 것인지 추적하고, 자주 쓰이지 않은 곳에 데이터를 저장시킨다.<br>
간단하게 구현이 가능하지만, 전체적인 데이터 블록 입장에서보자면 유동성이 떨어지고 이로인한 병목 현상이 일어날 수도 있다는 치명적인 단점이 있다.<br>
또한 특정 블록만이 자주 사용되어 해당 블록의 마모가 빨라져 전체적인 ssd의 성능에도 영향을 줄 수도 있다.
### 정적 웨어라벨링
대부분의 ssd는 동적인 데이터와 정적인 데이터를 둘다 웨어라벨링한다.<br>
정적 웨에라벨링은 정적인 데이터를 대상으로 진행하는 웨어라벨링으로, 자주 쓰여질 가능성이 적은 정보들까지 고려대상에 집어넣는다.<br>
그러나, 이러한 작업이 지나치게 자주 주기적으로 이루지면 과도한 오버헤드 현상(간접비용)이 발생할 수도 있다.<br>
또한 데이터를 관리하는 방법이 동적 웨어라벨링에 비하여 까다로우며, 쓰기 증폭(우리가 필요한 양보다 데이터가 많은 블록을 차지하는 현상)이 일어날 수도 있다.
### 글로벌 웨어라벨링
위에서 보았다시피 동적 웨어라벨링과 정적 웨어라벨링은 각각 다른 장단점을 가지고있다.<br>
글로벌 웨어라벨링은 모든 데이터를 대상으로 웨어라벨링을 하는 방식으로, 모든 데이터에게 쓰기 횟수의 균일성을 유지한다고 생각하면 된다.
## TRIM
우선 운영체젱서 trim기능을 지원해주어야한다.<br>
이 경우 os의 파일 시스템에서 삭제되거나, 사용되지 않는 데이터 블록이 발견되면 trim명령어를 통해 해당 블록이 지워도 상관없는 블록임을 표시해놓는다.<br>
이후 ssd는 해당 블록의 데이터가 사용하지 않는것임을 표기해놓는다.<br> 만약 이 논리적 주소가 사용될 일이 발생한다면 gc가 작동하여 여러개의 삭제 명령을 동시에실행할 수도 있다.<br>
trim을 사용하면 불필요한 데이터가 미리 삭제되므로, 새로운 데이터를 쓸 때에 불필요한 삭제가 일어나지 않아서 성능 향상에 도움이 되는데 이 부분은 다음 게시물인 ssd3편(삭제원리)에서 자세히 알아보도록 하자.