---
title:  "cs50 5강 메모리 주소와 포인터"
toc: true
toc_sticky: true
categories:
  - cs
tags:
  - 컴퓨터과학
  - cs50
toc_label: "cs 50 5강 중요내용"
header:
  teaser: "https://images.unsplash.com/photo-1602463843491-1becaf199ad8?q=80&w=2660&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
permalink: /categories/cs/CS50/ch5/session1
---
# 메모리 주소
메모리 주소를 표현할 때에는 앞서 말한 컴퓨터의 기본 의사소통 규칙(이진법 사용하기)와 조금 다른 규칙이 추가된다.<br>
`가상 메모리의 주소`를 표현할 때에는 16진법을 사용하기로 하나의 규약이 추가된다.<br>
왜 컴퓨터는 기본적으로 이진법 소통을 원칙으로 한다 해놓고서는, 메모리 주소만 16진법을 사용하는가 하는 의문이 든다면 정상이다.
## 바이트는 8비트이다
앞서 배운 내용을 굳이 한번 더 상기시키는 이유는 주소값에 대해서 16진법을 사용하는 이유와 바이트가 8개의 비트로 구성된 것이 관계있기 때문이다.<br>
이 8개의 비트를 반으로 나누어 4비트씩 잘라 보면, 4비트는 2의 4승 즉 16까지의 표현이 가능해진다.
## 이진수는 너무 길어진다
주소값의 경우 메모리의 크기와 관계있기 때문에 이진법을 사용시 주소값이 너무 길어질 수도 있다.<br>
따라서 2진법보다 좀 더 큰 진법을 골라야했고, 그중에서도 하필 16진법을 고른 것은 위에서 서술한 이유 때문이다.
## 출력하는 법
메모리상의 주소를 출력할 때에는 `&`를 사용한다.<br>
또한 주소값을 통해 실제 내용물을 출력하고 싶다면`*`을 쓰면 된다.<br>
만약 주소값을 모르는 상황이라면, `*&`을 쓰면 실제 내용물을 불러올 수 있다.
# 포인터
왜 포인터는 악명이 높을까?<br>
주소값은 주소일뿐, 안에 담긴 내용물은 주소값과 전혀 관계가 없는 것이 들어가있다.<br>
그러나 우리는 주소값을 통해서 내용물을 가져올 수 있다는 부분이 처음 접했을 때에는 굉장히 생소하게 다가오기 때문일 것이다.<br>
즉 포인터가 변수의 값(편의상 주소)와 그 변수의 값이 가리키는 데이터가 다름을 이해하는 것이 어려워서 도대체 이런걸 어디에 쓸까 하는 생각이 드는 경우가 대다수인 것 같다.
## 포인터 변수 선언과 출력

```c
#include<stdio.h>
int main() {
	int n = 50;
	int* p = &n;
	printf("%p\n", p);
	printf("%i\n", *p);
}
```
위 예문을 직접 출력해보면, 첫번째에는 주소값이 출력되고 두번째에 내용물이 출력되는 것을 알 수 있다.<br>
즉 포인터는 기본적으로 주소의 성격을 가지고 있고, 그 포인터의 내용물을 읽어와야 데이터를 출력할 수 있다.
# 포인터와 메모리의 크기
포인터는 `간접참조`의 형태로 작동한다.<br>
그렇기 때문에 포인터의 내용물이 double이든 int이든 char이든 컴파일os의 비트수만 변하지 않으면, 포인터의 크기는 같다.<br>
즉 포인터는 컴퓨터의 메모리 크기와 관계를 맺는다기 보다는 os의 비트수와 관계를 맺는다고 볼 수 있다.<br>
물론 메모리가 큰 컴퓨터가 보편화될시(현재 16비트 컴퓨터를 쓰지는 않으니) 포인터의 크기는 모든 주소값을 나타내기 위해 변화할 수 있으나, 직접적인 관계로 보기에는 무리가 있다.<br>
또한 cpu의 아키텍처에는 어드레스 버스의 크기가 정해져있으므로, 그에 따라 포인터의 주소가 변화할 수도 있다.<br>
포인터는 컴퓨터 메모리의 크기와 직접적 관계가 있는 것이 아니라 cpu의 아키텍처와 os의 비트수와 관계가 깊다.